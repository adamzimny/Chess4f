/*
   Copyright (C) 2015 Adam Zimny (adamzimny@gmail.com)
   This file is part of Chess4f.

    Chess4f is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Chess4f is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Chess4f.  If not, see <http://www.gnu.org/licenses/>.
 */
package chess4f.ui;

import chess4f.game.GameController;
import chess4f.domain.ChessBoard;
import chess4f.domain.Color;
import chess4f.domain.Move;
import chess4f.domain.PieceKind;
import chess4f.domain.Position;
import chess4f.domain.Piece;
import chess4f.game.HumanPlayer;
import chess4f.game.Player;
import chess4f.ui.pieces.PieceImageFactory;
import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.util.List;

/**
 *
 * @author Adam Zimny <adamzimny@gmail.com>
 */
public class BoardPanel extends javax.swing.JPanel implements GameController.MoveListener {

    private static final java.awt.Color COLOR_LIGHT = new java.awt.Color(200, 200, 150);
    private static final java.awt.Color COLOR_DARK = new java.awt.Color(100, 100, 150);
    private static final java.awt.Color COLOR_MOVE_HINT = new java.awt.Color(20, 100, 20);
    private static final java.awt.Color COLOR_HIGHLIGHT_CHECK = new java.awt.Color(200, 0, 0);
    private static final int LINE_WIDTH = 3;

    private Position selectedField = null;
    private GameController gameController = null;

    /**
     * Creates new form BoardPanel
     */
    public BoardPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        Player player = gameController.getPlayer(gameController.getTurn());
        if (!(player instanceof HumanPlayer)) {
            return;
        }

        Position clickedField = getLogicalPositionFromCoordinates(evt.getX(), evt.getY());

        // move
        if (selectedField != null && !selectedField.equals(clickedField)) {

            Move move = new Move(board.getPiece(selectedField), clickedField);
            if (!board.isMoveLegal(move)) {
                return;
            }
            //UndoBoard undo = board.movePiece(move);
            selectedField = null;

            ((HumanPlayer)player).humanPlayerMoved(move);
        } else {
            // new selection
            if ((selectedField == null || !selectedField.equals(clickedField)) && board.getPiece(clickedField) != null) {
                selectedField = clickedField;
            } else {
                selectedField = null;
            }
        }

        repaint();
    }//GEN-LAST:event_formMouseClicked

    ChessBoard board;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    public void setBoard(ChessBoard board) {
        this.board = board;
    }

    public void setGameController(GameController gameController) {
        this.gameController = gameController;

        // start the game
        new Thread(() -> {
            gameController.play();
        }).start();
    }

    @Override
    public void onMove(Move move) {
        repaint();
    }

    @Override
    public void paint(Graphics g_) {
        Graphics2D g = (Graphics2D) g_;

        int squareSize = Math.min(this.getWidth() - 1, this.getHeight() - 1) / 8;

        for (int r = 0; r < 8; r++) {
            for (int c = 0; c < 8; c++) {
                int logicalRow = 8 - r;
                int logicalCol = c + 1;

                // draw square
                Color fieldColor = board.getFieldColor(new Position(logicalRow, logicalCol));

                g.setColor(fieldColor == Color.BLACK ? COLOR_DARK : COLOR_LIGHT);
                g.fillRect(c * squareSize, r * squareSize, squareSize, squareSize);

                // draw figure
                Piece piece = board.getPiece(logicalRow, logicalCol);
                if (piece != null) {
                    Image image = PieceImageFactory.getImage(piece.getKind(), piece.getColor());
                    if (selectedField != null && selectedField.getCol() == logicalCol && selectedField.getRow() == logicalRow) {
                        g.drawImage(image, c * squareSize, r * squareSize, (int) (squareSize * 1.2F), (int) (squareSize * 1.2F), null);
                    } else {
                        g.drawImage(image, c * squareSize, r * squareSize, squareSize, squareSize, null);
                    }

                    // highlight field if under check
                    if (piece.getKind() == PieceKind.KING && board.isUnderCheck(piece.getColor())) {
                        g.setStroke(new BasicStroke(LINE_WIDTH));

                        g.setColor(COLOR_HIGHLIGHT_CHECK);
                        g.drawRect(c * squareSize + 1, r * squareSize + 1, squareSize - LINE_WIDTH, squareSize - LINE_WIDTH);
                    }
                }
            }
        }

        if (selectedField != null) {
            Piece piece = board.getPiece(selectedField);
            if (piece != null) {
                g.setColor(COLOR_MOVE_HINT);
                List<Position> allMoves = piece.getAllMoves(board, true);
                allMoves.stream().forEach((p) -> {
                    int x = (p.getCol() - 1) * squareSize + (int) (squareSize * 0.25F);
                    int y = squareSize * 8 - (p.getRow() * squareSize) + (int) (squareSize * 0.25F);
                    g.fillArc(x, y, squareSize / 2, squareSize / 2, 0, 360);
                });
            }
        }
    }

    private Position getLogicalPositionFromCoordinates(int x, int y) {
        int squareSize = Math.min(this.getWidth() - 1, this.getHeight() - 1) / 8;

        int row = 8 - (y / squareSize);
        int col = x / squareSize + 1;

        return new Position(row, col);
    }
}
